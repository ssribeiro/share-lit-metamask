import {
  IEthereumSubchainIdV1,
  IEthereumSubchainNameV1,
  IUniqueChainNameV1,
  IBitcoinWallet,
  ISubchainV1,
  ISupportedTokenNameV1,
  IBalancesResponse,
  ISupportedChain,
  SUPPORTED_CHAINS_LIST,
} from "@gvnrdao/sdk-browser";
import { ethers } from "ethers-6.13.2";
import { useEffect, useState, useRef } from "react";
import "./App.css";
import { PINATA_API, PINATA_SECRET, GROVE_API_KEY } from "./constants";
import { MetaMaskInpageProvider } from "@metamask/providers";

declare global {
  interface Window {
    ethereum: MetaMaskInpageProvider | undefined;
  }
}

const App = () => {
  const [metamaskStatus, setMetamaskStatus] = useState("Disconnected");
  // const [authenticationSigner, setAuthenticationSigner] = useState<
  //   ethers.Signer | undefined
  // >(undefined);
  const [chainUniqueName, setChainUniqueName] = useState<
    IUniqueChainNameV1 | undefined
  >(undefined);
  const [chainSubnetName, setChainSubnetName] = useState<
    IEthereumSubchainNameV1 | undefined
  >(undefined);
  const [chainSubnetId, setChainSubnetId] = useState<
    IEthereumSubchainIdV1 | undefined
  >(undefined);
  const [connectedEthereumAccount, setConnectedEthereumAccount] = useState<
    string | undefined
  >(undefined);
  const [currentChainProvider, setCurrentChainProvider] = useState<
    ethers.Provider | undefined
  >(undefined);
  const [currentSigner, setCurrentSigner] = useState<ethers.Signer | undefined>(
    undefined
  );
  const [currentSignerAndSetGvnrAuth, setCurrentSignerAndSetGvnrAuth] =
    useState<boolean>(false);
  const [gvnrAuthEthereumAccount, setGvnrAuthEthereumAccount] = useState<
    string | undefined
  >(undefined);
  // const [gvnrAuthChainProvider, setGvnrAuthChainProvider] = useState<
  //   ethers.Provider | undefined
  // >(undefined);
  const [gvnrAuthSigner, setGvnrAuthSigner] = useState<
    ethers.Signer | undefined
  >(undefined);
  // Create a ref for gvnrAuthSigner
  const gvnrAuthSignerRef = useRef<ethers.Signer | undefined>(gvnrAuthSigner);
  const [gvnrId, setGvnrId] = useState<string | undefined>(undefined);
  const [myEthereumAddress, setMyEthereumAddress] = useState<
    string | undefined
  >(undefined);
  const [myBitcoinAddress, setMyBitcoinAddress] = useState<string | undefined>(
    undefined
  );
  const [myBalances, setMyBalances] = useState<IBalancesResponse | undefined>(
    undefined
  );
  const [isOpenInvoiceAssetChainSelector, setIsOpenInvoiceAssetChainSelector] =
    useState(false);
  const [
    selectedInvoiceAssetChainSelector,
    setSelectedInvoiceAssetChainSelector,
  ] = useState<undefined | ISupportedChain>(undefined);

  /*
    const [targetGvnrId, setTargetGvnrId] = useState("");
    const [assetAmount, setAssetAmount] = useState("");
    const [assetToken, setAssetToken] = useState("");
    const [currencyAmount, setCurrencyAmount] = useState("");
    const [currencyToken, setCurrencyToken] = useState("");
    const [assetCurrencyPrice, setAssetCurrencyPrice] = useState(0);
    const [amountToPay, setAmountToPay] = useState(0);
    const [userPickChain, setUserPickChain] = useState("");
    */

  useEffect(() => {
    console.log("play!");
  }, []);

  // Update the ref whenever gvnrAuthSigner changes
  useEffect(() => {
    gvnrAuthSignerRef.current = gvnrAuthSigner;
  }, [gvnrAuthSigner]);

  // Configure the Gvnr SDK
  useEffect(() => {
    const getAuthenticationSigner = async (): Promise<ethers.Signer> => {
      if (gvnrAuthSignerRef.current === undefined) {
        await setGvnrAuth();
        while (gvnrAuthSignerRef.current === undefined) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
      return gvnrAuthSignerRef.current;
    };

    const getEvmSignerFromChainAndRpcUrl = async (
      chain: ISubchainV1,
      rpcUrl: string
    ): Promise<ethers.Signer> => {
      console.log("chain");
      console.log(chain);
      console.log("rpcUrl");
      console.log(rpcUrl);
      // if (!currentSigner) {
      throw new Error("Signer not set. Please connect to Metamask.");
      // }
      return currentSigner!;
    };

    window.Gvnr.config({
      gvnrContractConfig: {
        getSigner: async () => {
          return getAuthenticationSigner();
        }, // this is the signer for gvnr smart contracts operations
      },
      pinataStorageProviderConfig: {
        pinataApi: PINATA_API,
        pinataSecret: PINATA_SECRET,
      },
      pkpAuthenticationConfig: {
        authenticationMethod: "ethereumWallet",
        authenticationEthereumGetSigner: async () => {
          return getAuthenticationSigner();
        }, // this is the signer for ethereum pkps
      },
      litPkpConfig: {
        standaloneOrRelayer: "relayer",
      },
      // gvnrLitClientConfig: {
      //   // wsPort: "8080",
      //   // wsUrl: "ws://localhost",
      //   // wsPort: "80",
      //   // wsUrl: "https://5854-177-221-121-93.ngrok-free.app",
      // },
      litAuthConfig: {
        standaloneDomain: "http://localhost:3000",
        standaloneOrigin: "http://localhost:3000",
      },
      litNetwork: "datil",
    });
    const notUsedForBalances = async () => {
      throw new Error("There is not BTC wallet");
      return undefined as unknown as IBitcoinWallet;
    };
    window.Gvnr.ChainLibs.addLib(
      window.Gvnr.ChainLibs.BitcoinLib(
        "live",
        notUsedForBalances,
        async (): Promise<string> => {
          return "0.00001";
        }
      )
    );
    window.Gvnr.ChainLibs.addGroveEthereumLibs({
      skipSigner: false,
      apiKeySuffix: GROVE_API_KEY,
      getEvmSignerFromChainAndRpcUrl,
    });
    window.Gvnr.ChainLibs.addPublicEthereumLibs({
      skipSigner: false,
      getEvmSignerFromChainAndRpcUrl,
    });
  }, []);

  /*

  const mapOfChainIdToUniqueNameEthereum = new Map<
    number,
    IUniqueChainNameV1
  >();
  const mapOfUniqueNameToChainIdEthereum = new Map<
    IUniqueChainNameV1,
    number
  >();
  for (const chain of Object.values(window.gvnr.UNIQUE_CHAINS_V1)) {
    if (chain.chainId === 0) {
      const uniqueName = window.gvnr.uniqueNameFromChainRepresentationV1(chain);
      mapOfChainIdToUniqueNameEthereum.set(chain.chainId, uniqueName);
      mapOfUniqueNameToChainIdEthereum.set(uniqueName, chain.chainId);
    }
  }
*/
  /*
  const getEvmSignerFromChainAndRpcUrl = async (
    chain: string,
    rpcUrl: string
  ): Promise<ethers.Signer> => {
    if (!window.ethereum) {
      throw new Error("Metamask not detected. Please install Metamask.");
    }
  };
  */

  /*
  useEffect(() => {
    // Run Gvnr.config() once when the app loads
    if (window.env == undefined) {
      window.env = {};
    }
    window.env.TESTING_LOCAL_ETHEREUM_CHAIN = "true";
    window.env.TESTING_LOCAL_ETHEREUM_CHAIN_NAME = "MAINNET";
    Gvnr.config({
      gvnrContractConfig: {
        getSigner: local.user.receiver.getSigner, // this is the signer for gvnr smart contracts operations
        getContractAddresses: local.getContractAddresses,
      },
      pinataStorageProviderConfig: {
        pinataApi: getEnv("PINATA_API")!,
        pinataSecret: getEnv("PINATA_SECRET")!,
      },
      pkpAuthenticationConfig: {
        authenticationMethod: "ethereumWallet",
        authenticationEthereumGetSigner: local.user.receiver.getSigner, // this is the signer for ethereum pkps
      },
      litPkpConfig: {
        standaloneOrRelayer: "relayer",
      },
      gvnrLitClientConfig: {
        wsPort: "8080",
        wsUrl: "ws://localhost",
      },
      litNetwork: "datil-test",
      gvnrWalletsConfig: {
        debugUseFirstPkpInsteadOfMint: false,
      },
    });
    Gvnr.ChainLibs.addEthereumLibs({
      name: "local-test",
      urls: {
        [LOCAL.testChain]: "http://localhost:8545",
      },
      signerEvmPrivatekey: local.user.receiver.privateKey,
    });

    console.log("Gvnr configured.");
  }, []); // Empty dependency array ensures it runs only once
  */

  /*
  const getSigner = async (): Promise<ethers.Signer> => {
    if (!signer) {
      throw new Error("Signer not set. Please connect to Metamask.");
    }
    return signer;
  };
  */

  /*

  const setupChains = () => {
    const ethereumOnes = SUPPORTED_SUBCHAINS_V1.ETHEREUM;
    for (const chainKey of Object.keys(ethereumOnes)) {
      const chain = ethereumOnes[chainKey as keyof typeof ethereumOnes];
      const uniqueName = nameFromChainV1(chain);
      Gvnr.ChainLibs.addLib(
        Gvnr.ChainLibs.EthereumLib(uniqueName, () => {
          return getSigner();
        })
      );
    }
  };
  */

  const connectMetamask = async () => {
    console.log("Connecting to Metamask...");
    if (typeof window.ethereum !== "undefined") {
      try {
        const dealSetChainId = (chainId: string) => {
          const chainIdNumber = parseInt(chainId, 16) as IEthereumSubchainIdV1;
          const chainIdString = (+chainIdNumber).toString();
          const includes = (
            [...window.gvnr.SUPPORTED_ETHEREUM_SUBCHAIN_IDS_LIST_V1] as number[]
          ).includes(+chainIdNumber);
          if (!includes) {
            const supportedOnes = [
              ...window.gvnr.SUPPORTED_ETHEREUM_SUBCHAIN_NAMES_LIST_V1,
            ].join(", ");
            alert(
              "Please connect to a supported chain. The current chain is not supported. Current supported: " +
                supportedOnes
            );
            return;
          }
          setChainSubnetId(chainIdNumber as IEthereumSubchainIdV1);
          const chainSubnetName =
            window.gvnr.evmChainNameFromChainIdString(chainIdString);
          setChainSubnetName(chainSubnetName);
          const chainUniqueName =
            window.gvnr.uniqueNameFromEthereumSubchainName(chainSubnetName);
          setChainUniqueName(chainUniqueName);
        };

        const handleConnectedAccount = async () => {
          const provider = new ethers.BrowserProvider(window.ethereum!);
          setCurrentChainProvider(provider);
          const signer = await provider.getSigner();
          if (!signer) {
            alert(
              "Please connect to a wallet and allow the connection to the site."
            );
            return;
          }
          setCurrentSigner(signer);
          const addressOfSigner = await signer.getAddress();
          // console.log("addressOfSigner");
          // console.log(addressOfSigner);
          setConnectedEthereumAccount(addressOfSigner);
        };

        if (window.ethereum) {
          const chainId = await window.ethereum.request({
            method: "eth_chainId",
          });
          dealSetChainId(chainId as string);
          window.ethereum.on("chainChanged", (...args) => {
            dealSetChainId(args[0] as string);
          });
          window.ethereum.on("accountsChanged", () => {
            handleConnectedAccount();
          });
          handleConnectedAccount();
        }

        setMetamaskStatus("Connected");
      } catch (error) {
        console.error("Error connecting to Metamask", error);
      }
    } else {
      alert("Please install Metamask!");
    }
  };

  useEffect(() => {
    if (currentSigner && currentSignerAndSetGvnrAuth) {
      setGvnrAuth();
      setCurrentSignerAndSetGvnrAuth(false);
    }
  }, [currentSigner]);

  const frontendErrorHandler = (err: Error) => {
    console.log("err");
    console.log(err);
    if (
      err.message.indexOf(
        "Missing Revert Data: Do you have at least some gas for this operation?"
      ) !== -1
    ) {
      alert(
        "You don't have enough balance to perform this operation. Please add some gas. The how much depends on chain. For Polygon, is about 0.01 USD. For BASE, is about 3 USD."
      );
    } else if (
      err.message.indexOf(
        "safeContractMintCall: Transaction failed: Could not estimate gas: Error: insufficient funds"
      ) !== -1
    ) {
      alert(
        "You don't have enough balance to perform this operation. Please add some gas. The how much depends on chain. For Polygon, is about 0.01 USD. For BASE, is about 3 USD."
      );
    } else {
      throw new Error(
        "Minimalist Frontend: SDK Unknown Error:" + window.gvnr.errToStr(err)
      );
    }
    return undefined;
  };

  const setGvnrAuth = async () => {
    if (!currentSigner) {
      setCurrentSignerAndSetGvnrAuth(true);
      await connectMetamask();
      return;
    }
    setGvnrAuthEthereumAccount(connectedEthereumAccount);
    // setGvnrAuthChainProvider(currentChainProvider);
    setGvnrAuthSigner(currentSigner);
    await window.gvnr.ContractsModule.flushContracts();
  };

  const generateMyGvnrId = async () => {
    const gvnrId = await window.Gvnr.getMyGvnrId().catch(frontendErrorHandler);
    setGvnrId(gvnrId);
  };

  const getMyGvnrAddresses = async () => {
    const myWalletsSet = await window.Gvnr.getTargetWalletsSet(gvnrId!);
    setMyEthereumAddress(myWalletsSet.ethereum.latestPublicAddress);
    setMyBitcoinAddress(myWalletsSet.bitcoin.latestPublicAddress);
  };

  const getMyBalances = async () => {
    const myBalances = await window.Gvnr.Balances.get().catch(
      frontendErrorHandler
    );
    setMyBalances(myBalances);
  };

  const eraseMyBalances = () => {
    setMyBalances(undefined);
  };

  const generateAnInvoice = async () => {};

  const toggleDropdownInvoiceAssetChainSelector = () =>
    setIsOpenInvoiceAssetChainSelector(!isOpenInvoiceAssetChainSelector);

  const optionsInvoiceAssetChainSelector: ISupportedChain[] = [
    ...window.gvnr.SUPPORTED_CHAINS_LIST,
  ];

  const handleOptionClickInvoiceAssetChainSelector = (
    option: ISupportedChain
  ) => {
    setSelectedInvoiceAssetChainSelector(option);
    setIsOpenInvoiceAssetChainSelector(false);
  };

  /*

  const handleChainChange = async () => {
    if (window.ethereum) {
      await window.ethereum.request({ method: "eth_requestAccounts" });
      setMetamaskStatus("Connected");
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const network = await provider.getNetwork();
      setChain(network.name.toUpperCase());
      setSigner(signer);
      window.ethereum.on("chainChanged", async (chainId: string) => {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer = await provider.getSigner();
        const network = await provider.getNetwork();
        setChain(network.name.toUpperCase());
        setUserPickChain(network.name.toUpperCase());
        setSigner(signer);
      });
      window.ethereum.on("accountsChanged", async (accounts: string[]) => {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer = await provider.getSigner(accounts[0]);
        setSigner(signer);
      });
    }
  };

  const handleAccountChange = async () => {
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", async (accounts: string[]) => {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer = await provider.getSigner(accounts[0]);
        setSigner(signer);
      });
    }
  };

  useEffect(() => {
    setupChains();
    handleChainChange();
    handleAccountChange();
  }, []);

  */

  /*

  const transfer = async () => {
    if (!signer) {
      console.error("Signer not set. Please connect to Metamask.");
      return;
    }

    try {
      // Implement your transfer logic here using the signer
      const transferAmount = ethers.parseUnits(assetAmount, 18); // Assuming token uses 18 decimals
      console.log(`Transferring ${transferAmount.toString()} of ${assetToken}`);
      // Call the transfer function here using the signer
    } catch (error) {
      console.error("Error during transfer", error);
    }
  };

  */

  return (
    <div
      style={{
        marginLeft: "1em",
      }}
    >
      <h2>Metamask is: {metamaskStatus}</h2>
      <button onClick={connectMetamask}>Connect Metamask</button>
      <h3>My Chain Unique Name: {chainUniqueName || "N/A"}</h3>
      <h3>My Chain Subnet Name: {chainSubnetName || "N/A"}</h3>
      <h3>
        My Chain id: {chainSubnetId !== undefined ? "" + chainSubnetId : "N/A"}
      </h3>
      <h3>Connected Ethereum Account: {connectedEthereumAccount || "N/A"}</h3>
      <h3>
        -----------------------------------------------------------------------
      </h3>
      <button onClick={setGvnrAuth}>
        Set current connected account as Gvnr Auth Account
      </button>
      <h3>Gvnr Auth Account: {gvnrAuthEthereumAccount || "N/A"}</h3>
      <h3>
        -----------------------------------------------------------------------
      </h3>
      <button onClick={generateMyGvnrId}>Generate My GvnrId</button>
      <h3>My Gvnr Id is: {gvnrId}</h3>
      <h3>
        -----------------------------------------------------------------------
      </h3>
      <button onClick={getMyGvnrAddresses}>
        Get My Gvnr Wallet's addresses
      </button>
      <h3>My Gvnr Wallets Addresses Are</h3>
      <h3>Ethereum: {myEthereumAddress}</h3>
      <h3>Bitcoin: {myBitcoinAddress}</h3>
      <h3>
        -----------------------------------------------------------------------
      </h3>
      <button onClick={getMyBalances}>Get My Balances</button>
      <button onClick={eraseMyBalances}>Erase</button>
      <h3>My Balances:</h3>
      <div>
        {Object.keys(myBalances || {}).map((item, index) => (
          <div>
            <h5>{item}:</h5>
            <ul
              style={{
                margin: "0",
                marginBlock: "0",
                marginInlineStart: "0",
                marginInlineEnd: "0",
              }}
            >
              {Object.keys(myBalances![item as IUniqueChainNameV1] || {}).map(
                (item2, index2) => (
                  <li
                    style={{
                      margin: 0,
                      lineHeight: "0.7em",
                    }}
                  >
                    <p style={{ fontSize: "0.7em" }}>
                      {item2}:
                      {JSON.stringify(
                        myBalances![item as IUniqueChainNameV1]![
                          item2 as ISupportedTokenNameV1
                        ]!
                      )}
                    </p>
                  </li>
                )
              )}
            </ul>
          </div>
        ))}
      </div>
      <h3>
        -----------------------------------------------------------------------
      </h3>
      <h3>Generate an Invoice (Payment Request)</h3>
      <h3>
        Select Asset:
        <br></br>
        (Used To define the value worth that you want to receive. Note that the
        payer can choose to pay you this value worth in any token in any
        chain.):
      </h3>
      <h3>Invoice Asset: </h3>
      <div>
        Select Asset Chain:
        <div
          onClick={toggleDropdownInvoiceAssetChainSelector}
          role="button"
          tabIndex={0}
        >
          {selectedInvoiceAssetChainSelector}
        </div>
        {isOpenInvoiceAssetChainSelector && (
          <ul>
            {optionsInvoiceAssetChainSelector.map((option) => (
              <li
                key={option}
                onClick={() =>
                  handleOptionClickInvoiceAssetChainSelector(option)
                }
                role="button"
                tabIndex={0}
              >
                {option}
              </li>
            ))}
          </ul>
        )}
      </div>

      <button onClick={generateAnInvoice}>Generate!</button>
      <h3>My Gvnr Wallets Addresses Are</h3>
      <h3>Ethereum: {myEthereumAddress}</h3>
      <h3>Bitcoin: {myBitcoinAddress}</h3>
      <h3></h3>
      {/*

      <h3>If you want to pay:</h3>
      <input
        type="text"
        placeholder="Enter target GvnrId"
        onChange={(e) => setTargetGvnrId(e.target.value)}
      />
      <h4>Paying to: {targetGvnrId || "void"}</h4>

      <input
        type="text"
        placeholder="Asset Amount"
        onChange={(e) => setAssetAmount(e.target.value)}
      />
      <h4>
        Paying: {assetAmount || "0"} of {assetToken || "N/A"}
      </h4>

      <input
        type="text"
        placeholder="Asset Token"
        onChange={(e) => setAssetToken(e.target.value)}
      />

      <input
        type="text"
        placeholder="Currency Amount"
        onChange={(e) => setCurrencyAmount(e.target.value)}
      />

      <input
        type="text"
        placeholder="Currency Token"
        onChange={(e) => setCurrencyToken(e.target.value)}
      />
      <h4>
        You pay: {currencyAmount || "0"} of {currencyToken || "N/A"}
      </h4>

      <button onClick={transfer}>Transfer!</button>
    
      */}
    </div>
  );
};

export default App;
